'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fastify = require('fastify');
var dependencyScope = require('../decorators/helpers/dependency-scope.cjs');
var injectDependencies = require('../decorators/helpers/inject-dependencies.cjs');
var initializer = require('../decorators/initializer.cjs');
var _injectablesHolder = require('../registry/_injectables-holder.cjs');
var index = require('../symbols/index.cjs');
var fastifyPlugins = require('./fastify-plugins.cjs');
var mocksManager = require('./mocks-manager.cjs');

/**
 * @license
 * Copyright Andrey Chalkin <L2jLiga@gmail.com> (https://github.com/L2jLiga). All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/L2jLiga/fastify-decorators/blob/master/LICENSE
 */
/**
 * Configures service for testing
 * @param config with service and mocks
 * @returns configured service & promise which resolves when async initializer done (if it exists, otherwise resolved)
 */
function configureServiceTest(config) {
    const service = config.service;
    isInjectable(service);
    const injectablesWithMocks = mocksManager.MocksManager.create(_injectablesHolder._injectablesHolder, config.mocks);
    if (config.instance)
        injectablesWithMocks.injectSingleton(index.FastifyInstanceToken, config.instance);
    if (!injectablesWithMocks.has(index.FastifyInstanceToken))
        injectablesWithMocks.injectSingleton(index.FastifyInstanceToken, fastify.fastify(), false);
    const fastifyInstance = injectablesWithMocks.getSingleton(index.FastifyInstanceToken);
    const classLoader = injectDependencies.classLoaderFactory(injectablesWithMocks);
    classLoader.reset(dependencyScope.defaultScope);
    if (!fastifyInstance.hasDecorator(index.CLASS_LOADER))
        fastifyInstance.decorate(index.CLASS_LOADER, classLoader);
    fastifyPlugins.loadPlugins(fastifyInstance, config.plugins);
    const instance = service[index.CREATOR].register(classLoader);
    let promise = null;
    // @ts-expect-error TS doesn't know that we have class instance here
    return new Proxy(instance, {
        get(target, p) {
            if (p === 'then' || p === 'catch' || p === 'finally') {
                if (promise == null)
                    promise = hasAsyncInitializer(service)
                        ? // @ts-expect-error if service has async initializer then it exists in readyMap
                            initializer.initializersMap.get(service).then(() => target)
                        : Promise.resolve(target);
                return promise[p].bind(promise);
            }
            return target[p];
        },
    });
}
function isInjectable(service) {
    if (!(index.CREATOR in service)) {
        throw new Error('Provided service does not annotated with @Service!');
    }
}
function hasAsyncInitializer(service) {
    return index.INITIALIZER in service;
}

exports.configureServiceTest = configureServiceTest;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbbnVsbF0sInNvdXJjZXNDb250ZW50IjpbbnVsbF0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNENBQTJDO0FBQ3pFLGlDQUFpQywrQ0FBOEM7QUFDL0UsMEJBQTBCLCtCQUE4QjtBQUN4RCxpQ0FBaUMscUNBQW9DO0FBQ3JFLG9CQUFvQixzQkFBcUI7QUFDekMsNkJBQTZCLHVCQUFzQjtBQUNuRCwyQkFBMkIscUJBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsifQ==
